"""Topologies representing asynchronous computations
====================================================

Topologies representing all steps to achieve a computation. A topology is composed
of a bunch of Queues and Works.  Queues are used to temporarily saved items (in
RAM). Works take a item in a queue, do the job and put the result in another
Queue.

All topologies inherit from a base. This base has the structure for defining
queues and works.  A topology can be represented as a graph. This graph can be
generated by calling the topology.make_code_graphviz(name) function and then by
typing the unix command::

  dot {name_file}.dot -Tpng -o {name_file}.png && eog {name_file}.png

Users are particularly concerned with the PIV and preprocessing topologies:

.. autosummary::
   :toctree:

   piv
   bos
   preproc
   preproc_new
   image2image

These others modules defined classes and functions useful for developers.

.. autosummary::
   :toctree:

   base
   log
   launcher

"""

from pathlib import Path
import os
import sys

from fluiddyn.io.query import query

from .log import LogTopology
from .base import TopologyBase

__all__ = ["LogTopology", "TopologyBase"]


def prepare_path_dir_result(
    path_dir_input, path_saving, postfix_saving, how_saving
):
    """Makes new directory for results, if required, and returns its path."""

    path_dir_input = str(path_dir_input)

    if path_saving is not None:
        path_dir_result = path_saving
    else:
        path_dir_result = path_dir_input + "." + postfix_saving

    how = how_saving
    if os.path.exists(path_dir_result):
        if how == "ask":
            answer = query(
                "The directory {} ".format(path_dir_result)
                + "already exists. What do you want to do?\n"
                "New dir, Complete, Recompute or Stop?\n"
            )

            while answer.lower() not in ["n", "c", "r", "s"]:
                answer = query(
                    "The answer should be in ['n', 'c', 'r', 's']\n"
                    "Please type your answer again...\n"
                )

            if answer == "s":
                print("Stopped by the user.")
                sys.exit()

            elif answer == "n":
                how = "new_dir"
            elif answer == "c":
                how = "complete"
            elif answer == "r":
                how = "recompute"

        if how == "new_dir":
            i = 0
            while os.path.exists(path_dir_result + str(i)):
                i += 1
            path_dir_result += str(i)

    path_dir_result = Path(path_dir_result)
    path_dir_result.mkdir(exist_ok=True)
    return path_dir_result, how
